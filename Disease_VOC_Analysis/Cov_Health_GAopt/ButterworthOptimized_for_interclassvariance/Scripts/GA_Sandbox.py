
import multiprocessing
from deap import tools, algorithms
from Manduca_Multisite_EAG_Analysis.Disease_VOC_Analysis.Data_Processing.EAG_DataProcessing_Library import *
from Manduca_Multisite_EAG_Analysis.Disease_VOC_Analysis.Classification.EAG_Classifier_Library import *

def evaluate(individual, *args):
    butter_low, butter_high = individual
    # Call your process_data function with the given Butter arguments.
    process_data(DirList, savedir=f'{s}/YY_Normalized/Both_Channels/',
                 SUB=False, SUM=False, Norm='YY', Smoothen=False, LOG=False, Butter=[butter_low, butter_high], RETURN='SAVE')

    # Perform the classification on the processed data and calculate the accuracy.
    accuracy = perform_classification(*args)  # Pass any additional arguments needed for classification

    return accuracy,

def perform_classification(*args):
    # Your existing classification code should go here.
    # Modify it to return the accuracy value and handle the processed data generated by the process_data function with the given Butter arguments.

    # ...

    return accuracy

def parallel_evaluate(toolbox, population, num_processes, *args):
    with multiprocessing.Pool(processes=num_processes) as pool:
        fitnesses = pool.starmap(toolbox.evaluate, [(ind, *args) for ind in population])
        for ind, fit in zip(population, fitnesses):
            ind.fitness.values = fit


def main():
    num_processes = multiprocessing.cpu_count()

    # Additional arguments needed for classification
    classification_args = ()

    pop = toolbox.population(n=50)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)
    stats.register("max", np.max)

    # Main GA loop
    for gen in range(40):
        offspring = algorithms.varAnd(pop, toolbox, cxpb=0.5, mutpb=0.2)
        parallel_evaluate(toolbox, offspring, num_processes, *classification_args)
        pop = toolbox.select(offspring, k=len(pop))
        hof.update(pop)
        record = stats.compile(pop)
        print("Generation {}: {}".format(gen + 1, record))

    return pop, hof
